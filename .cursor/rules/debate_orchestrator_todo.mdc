---
description: debate_orchestrator 개선사항 todo list
globs:
alwaysApply: false
---
아래 코드를 기준으로 **오류/버그 → 흐름 단순화(설계) → 안정성/가독성 → 테스트성** 순으로 정리했습니다. 급한 것부터 고치시면 토론이 중간에 멈추거나 비정상 종료되는 문제를 즉시 줄일 수 있습니다.

---

## 1) 당장 수정해야 하는 **명백한 버그**

1. **문법 오류(Indentation / stray except)**

   * `_conduct_clash_round()` 내부:

     ```python
     enhanced_analysis['round_type'] = '직접_대결'
                         
                         challenge_msg = self.response_generator.generate_dynamic_manager_response(
         context_info, enhanced_analysis, panel_agents, round_number
     )
     ```

     위 `challenge_msg` 줄의 들여쓰기가 깨져 있습니다. 정상 들여쓰기로 수정하세요.
   * `_conduct_evidence_round()` 내부:
     `if False:` 블록 다음에 **대응하는 try가 없는 `except`** 가 남아 있습니다. 이 전체 `if False:` 블록(논쟁 심화 비활성화)과 그 뒤의 `except` 구문을 함께 제거하거나, 필요하다면 `try/except` 를 온전히 구성하세요. 현재 상태는 **실행 불가**입니다.

2. **반환 타입 불일치 (논리 오류)**

   * `_conduct_clash_round()` 상단에서 `len(panel_agents) < 2` 인 경우:

     ```python
     self._conduct_normal_round(round_number, panel_agents, analysis)
     return   # (현재는 반환값 없음 → None)
     ```

     이 메서드는 `bool` 을 반환하도록 설계되었습니다. 예:

     ```python
     return self._conduct_normal_round(round_number, panel_agents, analysis)
     ```

     로 바꿔 일관되게 `True/False` 를 반환하세요.

3. **패널 삽입 위치 제약 불일치**

   * 주석은 “**첫 번째나 마지막이 아닌 중간 위치**”라 했지만 실제 구현은 다음과 같아 마지막에도 들어갈 수 있습니다.

     ```python
     insert_position = random.randint(1, len(panel_agents))  # 끝(index == len) 포함
     ```

     수정:

     ```python
     insert_position = random.randint(1, len(panel_agents) - 1)
     ```

4. **미사용 변수 및 주석 불일치**

   * `conduct_dynamic_debate()` 에서 `intervention_threshold` 를 정의해 놓고 **사용하지 않습니다.** 실제 개입 로직(조기 종료/연장)에 반영하거나, 최소한 제거하여 혼란을 줄이세요.
   * “2라운드 -> 1라운드로 축소” 같은 **주석이 코드 동작과 상충**됩니다. 주석을 동작과 맞추거나 제거하세요.

5. **출력 경로 혼선**

   * 콘솔 `print()` 와 `presenter` 가 **혼재**되어 있습니다. 출력 경로가 두 갈래면 UI/로깅이 자주 깨집니다. 헤더/구분선 포함 **모든 출력은 `presenter` 로 일원화** 하세요.

---

## 2) **흐름 제어 복잡도**를 낮추는 구조 리팩토링

현 로직은 `if/elif` 가지치기와 여러 “라운드 타입”이 뒤섞여 복잡도가 상승하고 있습니다. 아래 두 단계로 단순화하면 **가독성/추론가능성/테스트성**이 크게 개선됩니다.

### 2.1 상태 모델 정규화 (단일 소스 오브 트루스)

`all_statements: List[dict]` 대신 **명시적 데이터모델**을 두세요.

```python
from dataclasses import dataclass, field
from typing import List, Literal, Optional

RoundType = Literal["initial", "normal", "provoke", "clash", "angle_change", "evidence", "final"]

@dataclass
class Statement:
    agent_name: str
    round_no: int
    round_type: RoundType
    content: str

@dataclass
class DebateState:
    topic: str
    phase: Literal["intro", "debate", "conclusion"]
    round_no: int = 0
    round_type: RoundType = "normal"
    temperature: Literal["cold","stuck","neutral","heated"] = "neutral"
    last_round_type: Optional[RoundType] = None
    last_change_angle_round: int = -10
    statements: List[Statement] = field(default_factory=list)
```

* 장점: **상태 및 기록의 불변성/일관성** 확보. 후처리(요약/결론)도 단순해집니다.

### 2.2 라운드 전략(Strategy) 분리

라운드 별 로직을 각각의 **전략 클래스로 분리**합니다. `next_action`(LLM 분석 결과)을 키로 매핑하고, 실패 시 폴백을 일관적으로 처리합니다.

```python
class RoundContext(Protocol):
    def ask(self, agent, context: str, statements: list[str]) -> str: ...
    def say_as_manager(self, msg: str) -> None: ...
    def ui_break(self) -> None: ...

class RoundStrategy(Protocol):
    def run(self, state: DebateState, panel_agents: list, analysis: dict, ctx: RoundContext) -> bool: ...

class NormalRound(RoundStrategy): ...
class ProvokeRound(RoundStrategy): ...
class ClashRound(RoundStrategy): ...
class AngleChangeRound(RoundStrategy): ...
class EvidenceRound(RoundStrategy): ...
```

오케스트레이터는 다음처럼 심플해집니다.

```python
STRATEGIES = {
  "continue_normal": NormalRound(),
  "provoke_debate": ProvokeRound(),
  "focus_clash": ClashRound(),
  "change_angle": AngleChangeRound(),
  "pressure_evidence": EvidenceRound(),
}

action = (analysis or {}).get("next_action", "continue_normal")
strategy = STRATEGIES.get(action, STRATEGIES["continue_normal"])
round_completed = strategy.run(state, panel_agents, analysis or {}, ctx)
if not round_completed:
    # 공통 폴백: normal 라운드 1회 시도 후 그래도 실패면 강제 다음 라운드
    round_completed = STRATEGIES["continue_normal"].run(state, panel_agents, {}, ctx)
```

* 장점: **분기 폭발 방지**, 개별 라운드의 **독립 테스트 가능**, 신규 라운드 타입 추가 쉬움.

---

## 3) **LLM 경계 관리**: 분석/지목 결과의 검증과 폴백

LLM 결과(`analyze_debate_state`, `analyze_manager_message`)는 **불완전/모호**할 수 있습니다. 항상 밸리데이션을 거치고, 실패 시 폴백합니다.

```python
def validate_analysis(analysis: dict, panel_agents: list) -> dict:
    out = dict(analysis or {})
    names = {a.name for a in panel_agents}
    # next_action 보정
    out["next_action"] = out.get("next_action") if out.get("next_action") in {
        "provoke_debate","focus_clash","change_angle","pressure_evidence","continue_normal"
    } else "continue_normal"
    # temperature 보정
    out["temperature"] = out.get("temperature") if out.get("temperature") in {
        "cold","stuck","neutral","heated"
    } else "neutral"
    # targeted_panels 정합성
    t = [p for p in out.get("targeted_panels", []) if p in names]
    out["targeted_panels"] = t
    return out
```

* `targeted_panels` 가 비면 **전략 내 공통 폴백**(예: `NormalRound`)으로 즉시 전환.
* `analysis_frequency` 로 인해 분석이 비어 있는 라운드에는 **그냥 Normal**.

---

## 4) **시간/랜덤성 의존성 분리** (테스트와 재현성)

* `time.sleep()` 을 곳곳에서 호출하면 테스트가 느리고 불안정합니다. 다음처럼 **주입(Injection)** 하세요.

  ```python
  class Sleeper: 
      def sleep(self, sec: float): time.sleep(sec)

  def __init__(..., sleeper: Sleeper = None, rng: random.Random = None):
      self.sleeper = sleeper or Sleeper()
      self.rng = rng or random.Random()
  ```

  테스트에서는 `NoopSleeper` 를 주입해 지연 제거, `random.Random(seed)` 로 **재현 가능성** 확보.

---

## 5) **출력/프레젠테이션 경로 단일화**

* 모든 텍스트/구분선/헤더는 `presenter` 를 통해서만 출력.
* `print()` 제거, `presenter.display_*` 로 통일.
* 라운드 전환/완료 표시도 `presenter.display_round_complete(round_no)` 같은 메서드로 추상화.

---

## 6) **설정 스키마 검증**(초기에 실패하게)

* `pydantic`(또는 최소한 수동 검증)으로 `config` 구조를 강제:

  * `debate.mode ∈ {"static","dynamic"}`
  * `debate.debate_rounds: int >= 1`
  * `debate.dynamic_settings.max_rounds >= debate_rounds`
  * `analysis_frequency >= 1`
  * `intervention_threshold ∈ {"cold","stuck","neutral","heated"}` (실제로 사용)

검증 실패 시 **초기화에서 예외**로 빠르게 실패하도록.

---

## 7) **로깅 표준화(구조화 로깅)**

* `logging` 에 JSON 구조(라운드/타입/타겟/온도/시간)를 남기면 사후 디버깅이 쉬워집니다.
* 각 발화에 `utterance_id`, 각 라운드에 `round_id`(예: `f"{round_no}-{round_type}"`) 부여.

---

## 8) **반복/정체 해소 규칙 명시적 관리**

* 현재 “미완료 라운드 → `current_round -= 1`” 로 **무한 루프 위험**이 있습니다.
  라운드별 **실패 허용 횟수(예: 1회)** 를 두고, 실패 시 강제 `Normal` → 그래도 실패면 **그 라운드는 완료 처리**하고 다음 라운드로 넘어가세요.
* “새로운 관점(change\_angle) 쿨다운” 등 **히스테리시스**는 `DebateState` 필드로 일원화.

---

## 9) **작은 리팩토링/정리 포인트**

* 문자열 상수(라벨/키)는 **Enum** 또는 상수 모듈로 추출.
* `List` → `List[PanelAgent]` 등 **제네릭 타입 명시**.
* `PanelHuman` 외에 **공통 인터페이스(Protocol/BaseClass)** 를 명확히 해 IDE/타입체커 도움을 받으세요.
* `ResponseGenerator` 가 “스트리밍 출력됨”을 전제로 문자열 반환/스트리밍을 섞어 쓰지 말고,
  **반환은 항상 문자열**로 하고, 스트리밍은 `presenter` 가 담당하도록 경계 분리.

---

## 10) **우선순위 적용 체크리스트 (권장 1\~2일)**

1. **버그 픽스**: 들여쓰기/`except`/반환타입/삽입 인덱스/미사용 변수 제거.
2. **출력 일원화**: `print()` 제거, `presenter` 로 통일.
3. **LLM 결과 검증 레이어**: `validate_analysis()` 추가 및 모든 전략 진입 전 적용.
4. **무한루프 방지**: 라운드 실패 허용 1회 + 폴백 Normal + 강제 라운드 종료.
5. **데이터모델 도입**: `Statement`, `DebateState` 로 교체하고 전 메서드 서명 정리.
6. **전략 패턴 도입**: 다섯 라운드 전략 클래스로 분리, 매핑 테이블로 호출.
7. **Sleep/Random 주입**: 테스트에서 No-op/seed 적용.
8. **Config 검증**: 초기화 시 스키마 체크, 실패는 즉시 예외.

---

## (참고) 최소 수정 예시 Diff 조각

**a) `_conduct_clash_round` 반환/들여쓰기**

```diff
-        enhanced_analysis['round_type'] = '직접_대결'
-                        
-                        challenge_msg = self.response_generator.generate_dynamic_manager_response(
-                    context_info, enhanced_analysis, panel_agents, round_number
-                )
+        enhanced_analysis['round_type'] = '직접_대결'
+        challenge_msg = self.response_generator.generate_dynamic_manager_response(
+            context_info, enhanced_analysis, panel_agents, round_number
+        )
         self.presenter.display_manager_message(challenge_msg)

-        if len(panel_agents) >= 2:
+        if len(panel_agents) >= 2:
             agent1, agent2 = panel_agents[0], panel_agents[1]
             other_agents = panel_agents[2:]
         else:
-            self._conduct_normal_round(round_number, panel_agents, analysis)
-            return
+            return self._conduct_normal_round(round_number, panel_agents, analysis)
```

**b) `_conduct_evidence_round` stray except 제거**

```diff
-            if False:  # 논쟁 심화 비활성화
-                ...
-            except Exception as e:
-                if self.config['debate'].get('show_debug_info', False):
-                    print(f"🎯 [디버그] 논쟁 심화 단계에서 오류 발생, 라운드 종료: {e}")
+            # (논쟁 심화 비활성화: 제거됨)
```

**c) 사용자 패널 삽입 위치**

```diff
- insert_position = random.randint(1, len(panel_agents))
+ insert_position = random.randint(1, len(panel_agents) - 1)
```

**d) 미사용 변수 정리 또는 실제 반영**

```diff
- intervention_threshold = dynamic_settings.get('intervention_threshold', 'cold')
+ intervention_threshold = dynamic_settings.get('intervention_threshold', 'cold')
+ # 예: 조기 종료 조건의 최소 온도 임계치로 사용
+ threshold_order = ["cold","stuck","neutral","heated"]
+ min_idx = threshold_order.index(intervention_threshold)
...
- if analysis and analysis.get('temperature') in ['cold', 'stuck']:
+ if analysis and threshold_order.index(analysis.get('temperature','neutral')) <= min_idx:
```

---

## 마무리

위 **버그 픽스 + 전략/상태 분리**만으로도 토론 흐름 제어의 예측 가능성이 크게 올라갑니다. 이후에는 각 전략을 **독립 유닛테스트**로 검증하면서, LLM 분석 실패 시 폴백이 항상 안전하게 작동하는지(무한루프 방지)만 꾸준히 체크하시면 안정성이 빠르게 확보됩니다.

원하시면, 현재 코드베이스에 맞춘 **라운드 전략 스켈레톤 클래스**와 `DebateState` 적용 패치 초안을 바로 만들어 드리겠습니다.
